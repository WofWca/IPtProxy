diff --git a/client/client_test.go b/client/client_test.go
index 84e9cc1..52a4cfe 100644
--- a/client/client_test.go
+++ b/client/client_test.go
@@ -1,4 +1,4 @@
-package main
+package snowflakeclient
 
 import (
 	"testing"
diff --git a/client/snowflake.go b/client/snowflake.go
index a1b97fa..d3db124 100644
--- a/client/snowflake.go
+++ b/client/snowflake.go
@@ -1,24 +1,19 @@
 // Client transport plugin for the Snowflake pluggable transport.
-package main
+package snowflakeclient
 
 import (
 	"flag"
-	"io"
-	"io/ioutil"
 	"log"
 	"math/rand"
 	"net"
 	"os"
-	"os/signal"
 	"path/filepath"
 	"strings"
-	"syscall"
 	"time"
 
 	pt "git.torproject.org/pluggable-transports/goptlib.git"
 	sf "git.torproject.org/pluggable-transports/snowflake.git/client/lib"
 	"git.torproject.org/pluggable-transports/snowflake.git/common/nat"
-	"git.torproject.org/pluggable-transports/snowflake.git/common/safelog"
 	"github.com/pion/webrtc/v2"
 )
 
@@ -26,6 +21,9 @@ const (
 	DefaultSnowflakeCapacity = 1
 )
 
+var listeners = make([]net.Listener, 0)
+
+
 // Accept local SOCKS connections and pass them to the handler.
 func socksAcceptLoop(ln *pt.SocksListener, tongue sf.Tongue) {
 	defer ln.Close()
@@ -74,16 +72,22 @@ func parseIceServers(s string) []webrtc.ICEServer {
 	return servers
 }
 
-func main() {
-	iceServersCommas := flag.String("ice", "", "comma-separated list of ICE servers")
-	brokerURL := flag.String("url", "", "URL of signaling broker")
-	frontDomain := flag.String("front", "", "front domain")
-	logFilename := flag.String("log", "", "name of log file")
-	logToStateDir := flag.Bool("log-to-state-dir", false, "resolve the log file relative to tor's pt state dir")
-	keepLocalAddresses := flag.Bool("keep-local-addresses", false, "keep local LAN address ICE candidates")
-	unsafeLogging := flag.Bool("unsafe-logging", false, "prevent logs from being scrubbed")
-	max := flag.Int("max", DefaultSnowflakeCapacity,
-		"capacity for number of multiplexed WebRTC peers")
+// Start the Snowflake client.
+func Start(ice, url, front, logFile string, logToStateDir, keepLocalAddresses, unsafeLogging *bool, maxPeers int) {
+	// Workaround for missing session configurability via SOCKS username/password.
+	// (As it actually should be per Pluggable Transports spec v1.)
+	if maxPeers < DefaultSnowflakeCapacity {
+		maxPeers = DefaultSnowflakeCapacity
+	}
+
+	iceServersCommas := flag.String("ice", ice, "comma-separated list of ICE servers")
+	brokerURL := flag.String("url", url, "URL of signaling broker")
+	frontDomain := flag.String("front", front, "front domain")
+	logFilename := flag.String("log", logFile, "name of log file")
+	logToStateDir = flag.Bool("log-to-state-dir", *logToStateDir, "resolve the log file relative to tor's pt state dir")
+	keepLocalAddresses = flag.Bool("keep-local-addresses", *keepLocalAddresses, "keep local LAN address ICE candidates")
+	unsafeLogging = flag.Bool("unsafe-logging", *unsafeLogging, "prevent logs from being scrubbed")
+	max := flag.Int("max", maxPeers, "capacity for number of multiplexed WebRTC peers")
 
 	// Deprecated
 	oldLogToStateDir := flag.Bool("logToStateDir", false, "use -log-to-state-dir instead")
@@ -98,7 +102,7 @@ func main() {
 	// buffer is full.
 	// https://bugs.torproject.org/26360
 	// https://bugs.torproject.org/25600#comment:14
-	var logOutput = ioutil.Discard
+	//var logOutput = ioutil.Discard
 	if *logFilename != "" {
 		if *logToStateDir || *oldLogToStateDir {
 			stateDir, err := pt.MakeStateDir()
@@ -113,13 +117,13 @@ func main() {
 			log.Fatal(err)
 		}
 		defer logFile.Close()
-		logOutput = logFile
+		//logOutput = logFile
 	}
 	if *unsafeLogging {
-		log.SetOutput(logOutput)
+		//log.SetOutput(logOutput)
 	} else {
 		// We want to send the log output through our scrubber first
-		log.SetOutput(&safelog.LogScrubber{Output: logOutput})
+		//log.SetOutput(&safelog.LogScrubber{Output: logOutput})
 	}
 
 	log.Println("\n\n\n --- Starting Snowflake Client ---")
@@ -159,12 +163,12 @@ func main() {
 		pt.ProxyError("proxy is not supported")
 		os.Exit(1)
 	}
-	listeners := make([]net.Listener, 0)
+
 	for _, methodName := range ptInfo.MethodNames {
 		switch methodName {
 		case "snowflake":
 			// TODO: Be able to recover when SOCKS dies.
-			ln, err := pt.ListenSocks("tcp", "127.0.0.1:0")
+			ln, err := pt.ListenSocks("tcp", "127.0.0.1:52610")
 			if err != nil {
 				pt.CmethodError(methodName, err.Error())
 				break
@@ -178,26 +182,9 @@ func main() {
 		}
 	}
 	pt.CmethodsDone()
+}
 
-	sigChan := make(chan os.Signal, 1)
-	signal.Notify(sigChan, syscall.SIGTERM)
-
-	if os.Getenv("TOR_PT_EXIT_ON_STDIN_CLOSE") == "1" {
-		// This environment variable means we should treat EOF on stdin
-		// just like SIGTERM: https://bugs.torproject.org/15435.
-		go func() {
-			if _, err := io.Copy(ioutil.Discard, os.Stdin); err != nil {
-				log.Printf("calling io.Copy(ioutil.Discard, os.Stdin) returned error: %v", err)
-			}
-			log.Printf("synthesizing SIGTERM because of stdin close")
-			sigChan <- syscall.SIGTERM
-		}()
-	}
-
-	// Wait for a signal.
-	<-sigChan
-
-	// Signal received, shut down.
+func Stop() {
 	for _, ln := range listeners {
 		ln.Close()
 	}
