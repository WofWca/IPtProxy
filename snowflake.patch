diff --git a/client/client_test.go b/client/client_test.go
index 84e9cc1..52a4cfe 100644
--- a/client/client_test.go
+++ b/client/client_test.go
@@ -1,4 +1,4 @@
-package main
+package snowflakeclient
 
 import (
 	"testing"
diff --git a/client/lib/snowflake.go b/client/lib/snowflake.go
index e888160..6ac0a51 100644
--- a/client/lib/snowflake.go
+++ b/client/lib/snowflake.go
@@ -174,6 +174,8 @@ func Handler(socks net.Conn, tongue Tongue) error {
 	log.Printf("---- Handler: closed stream %v ---", stream.ID())
 	snowflakes.End()
 	log.Printf("---- Handler: end collecting snowflakes ---")
+	// The session gets broken somehow. Remove it here, so we get a fresh one on restart.
+	sessionManager.sess = nil
 	return nil
 }
 
diff --git a/client/lib/webrtc.go b/client/lib/webrtc.go
index af5a45a..3a23ffc 100644
--- a/client/lib/webrtc.go
+++ b/client/lib/webrtc.go
@@ -112,7 +112,10 @@ func (c *WebRTCPeer) connect(config *webrtc.Configuration, broker *BrokerChannel
 	if err != nil {
 		return err
 	}
-	answer := exchangeSDP(broker, c.pc.LocalDescription())
+	answer, err := broker.Negotiate(c.pc.LocalDescription())
+	if err != nil {
+		return err
+	}
 	log.Printf("Received Answer.\n")
 	err = c.pc.SetRemoteDescription(*answer)
 	if nil != err {
@@ -217,22 +220,6 @@ func (c *WebRTCPeer) establishDataChannel() (*webrtc.DataChannel, error) {
 	}
 }
 
-// exchangeSDP sends the local SDP offer to the Broker, awaits the SDP answer,
-// and returns the answer.
-func exchangeSDP(broker *BrokerChannel, offer *webrtc.SessionDescription) *webrtc.SessionDescription {
-	// Keep trying the same offer until a valid answer arrives.
-	for {
-		// Send offer to broker (blocks).
-		answer, err := broker.Negotiate(offer)
-		if err == nil {
-			return answer
-		}
-		log.Printf("BrokerChannel Error: %s", err)
-		log.Printf("Failed to retrieve answer. Retrying in %v", ReconnectTimeout)
-		<-time.After(ReconnectTimeout)
-	}
-}
-
 // Close all channels and transports
 func (c *WebRTCPeer) cleanup() {
 	// Close this side of the SOCKS pipe.
diff --git a/client/snowflake.go b/client/snowflake.go
index a1b97fa..42ddcb4 100644
--- a/client/snowflake.go
+++ b/client/snowflake.go
@@ -1,8 +1,7 @@
 // Client transport plugin for the Snowflake pluggable transport.
-package main
+package snowflakeclient
 
 import (
-	"flag"
 	"io"
 	"io/ioutil"
 	"log"
@@ -26,8 +25,10 @@ const (
 	DefaultSnowflakeCapacity = 1
 )
 
+var sigChan = make(chan os.Signal, 1)
+
 // Accept local SOCKS connections and pass them to the handler.
-func socksAcceptLoop(ln *pt.SocksListener, tongue sf.Tongue) {
+func socksAcceptLoop(ln *pt.SocksListener, tongue sf.Tongue, shutdown chan struct{}) {
 	defer ln.Close()
 	for {
 		conn, err := ln.AcceptSocks()
@@ -48,11 +49,23 @@ func socksAcceptLoop(ln *pt.SocksListener, tongue sf.Tongue) {
 				return
 			}
 
-			err = sf.Handler(conn, tongue)
-			if err != nil {
-				log.Printf("handler error: %s", err)
+			handler := make(chan struct{})
+			go func() {
+				err = sf.Handler(conn, tongue)
+				if err != nil {
+					log.Printf("handler error: %s", err)
+				}
+				close(handler)
 				return
+
+			}()
+			select {
+			case <-shutdown:
+				log.Println("Received shutdown signal")
+			case <-handler:
+				log.Println("Handler ended")
 			}
+			return
 		}()
 	}
 }
@@ -74,22 +87,15 @@ func parseIceServers(s string) []webrtc.ICEServer {
 	return servers
 }
 
-func main() {
-	iceServersCommas := flag.String("ice", "", "comma-separated list of ICE servers")
-	brokerURL := flag.String("url", "", "URL of signaling broker")
-	frontDomain := flag.String("front", "", "front domain")
-	logFilename := flag.String("log", "", "name of log file")
-	logToStateDir := flag.Bool("log-to-state-dir", false, "resolve the log file relative to tor's pt state dir")
-	keepLocalAddresses := flag.Bool("keep-local-addresses", false, "keep local LAN address ICE candidates")
-	unsafeLogging := flag.Bool("unsafe-logging", false, "prevent logs from being scrubbed")
-	max := flag.Int("max", DefaultSnowflakeCapacity,
-		"capacity for number of multiplexed WebRTC peers")
+// Start the Snowflake client.
+func Start(iceServersCommas, brokerURL, frontDomain, logFilename *string, logToStateDir, keepLocalAddresses, unsafeLogging *bool, max *int) {
+	if *max < DefaultSnowflakeCapacity {
+		*max = DefaultSnowflakeCapacity
+	}
 
 	// Deprecated
-	oldLogToStateDir := flag.Bool("logToStateDir", false, "use -log-to-state-dir instead")
-	oldKeepLocalAddresses := flag.Bool("keepLocalAddresses", false, "use -keep-local-addresses instead")
-
-	flag.Parse()
+	oldLogToStateDir := logToStateDir
+	oldKeepLocalAddresses := keepLocalAddresses
 
 	log.SetFlags(log.LstdFlags | log.LUTC)
 
@@ -160,17 +166,18 @@ func main() {
 		os.Exit(1)
 	}
 	listeners := make([]net.Listener, 0)
+	shutdown := make(chan struct{})
 	for _, methodName := range ptInfo.MethodNames {
 		switch methodName {
 		case "snowflake":
 			// TODO: Be able to recover when SOCKS dies.
-			ln, err := pt.ListenSocks("tcp", "127.0.0.1:0")
+			ln, err := pt.ListenSocks("tcp", "127.0.0.1:52610")
 			if err != nil {
 				pt.CmethodError(methodName, err.Error())
 				break
 			}
 			log.Printf("Started SOCKS listener at %v.", ln.Addr())
-			go socksAcceptLoop(ln, dialer)
+			go socksAcceptLoop(ln, dialer, shutdown)
 			pt.Cmethod(methodName, ln.Version(), ln.Addr())
 			listeners = append(listeners, ln)
 		default:
@@ -179,7 +186,6 @@ func main() {
 	}
 	pt.CmethodsDone()
 
-	sigChan := make(chan os.Signal, 1)
 	signal.Notify(sigChan, syscall.SIGTERM)
 
 	if os.Getenv("TOR_PT_EXIT_ON_STDIN_CLOSE") == "1" {
@@ -196,14 +202,21 @@ func main() {
 
 	// Wait for a signal.
 	<-sigChan
+	log.Println("stopping snowflake")
 
 	// Signal received, shut down.
 	for _, ln := range listeners {
 		ln.Close()
 	}
+	close(shutdown)
 	log.Println("snowflake is done.")
 }
 
+func Stop() {
+	log.Println("synthesizing SIGTERM because of explicit Stop call")
+	sigChan <- syscall.SIGTERM
+}
+
 // loop through all provided STUN servers until we exhaust the list or find
 // one that is compatable with RFC 5780
 func updateNATType(servers []webrtc.ICEServer, broker *sf.BrokerChannel) {
diff --git a/proxy/proxy-go_test.go b/proxy/proxy-go_test.go
index e2fb82e..f3232b8 100644
--- a/proxy/proxy-go_test.go
+++ b/proxy/proxy-go_test.go
@@ -1,4 +1,4 @@
-package main
+package snowflakeproxy
 
 import (
 	"bytes"
diff --git a/proxy/snowflake.go b/proxy/snowflake.go
index f0fa2c0..1a6ab0c 100644
--- a/proxy/snowflake.go
+++ b/proxy/snowflake.go
@@ -1,10 +1,9 @@
-package main
+package snowflakeproxy
 
 import (
 	"bytes"
 	"crypto/rand"
 	"encoding/base64"
-	"flag"
 	"fmt"
 	"io"
 	"io/ioutil"
@@ -172,6 +171,12 @@ func getToken() {
 }
 
 func retToken() {
+	defer func() {
+		if r := recover(); r != nil {
+			// Recover if tokens got closed. That's ok, we're just getting stopped.
+		}
+	}()
+
 	tokens <- true
 }
 
@@ -507,22 +512,22 @@ func runSession(sid string) {
 	}
 }
 
-func main() {
-	var capacity uint
-	var stunURL string
-	var logFilename string
-	var rawBrokerURL string
-	var unsafeLogging bool
-	var keepLocalAddresses bool
-
-	flag.UintVar(&capacity, "capacity", 10, "maximum concurrent clients")
-	flag.StringVar(&rawBrokerURL, "broker", defaultBrokerURL, "broker URL")
-	flag.StringVar(&relayURL, "relay", defaultRelayURL, "websocket relay URL")
-	flag.StringVar(&stunURL, "stun", defaultSTUNURL, "stun URL")
-	flag.StringVar(&logFilename, "log", "", "log filename")
-	flag.BoolVar(&unsafeLogging, "unsafe-logging", false, "prevent logs from being scrubbed")
-	flag.BoolVar(&keepLocalAddresses, "keep-local-addresses", false, "keep local LAN address ICE candidates")
-	flag.Parse()
+func Start(capacity uint, rawBrokerURL, relayURL, stunURL, logFilename string, unsafeLogging, keepLocalAddresses bool) {
+	if capacity < 1 {
+		capacity = 10
+	}
+
+	if rawBrokerURL == "" {
+		rawBrokerURL = defaultBrokerURL
+	}
+
+	if relayURL == "" {
+		relayURL = defaultRelayURL
+	}
+
+	if stunURL == "" {
+		stunURL = defaultSTUNURL
+	}
 
 	var logOutput io.Writer = os.Stderr
 	log.SetFlags(log.LstdFlags | log.LUTC)
@@ -577,13 +582,16 @@ func main() {
 	checkNATType(config, defaultProbeURL)
 	log.Printf("NAT type: %s", currentNATType)
 
-	for {
-		getToken()
+	for range tokens {
 		sessionID := genSessionID()
 		runSession(sessionID)
 	}
 }
 
+func Stop() {
+	close(tokens)
+}
+
 func checkNATType(config webrtc.Configuration, probeURL string) {
 
 	var err error
